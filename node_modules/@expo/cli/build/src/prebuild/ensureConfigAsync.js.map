{"version":3,"sources":["../../../src/prebuild/ensureConfigAsync.ts"],"sourcesContent":["import { ExpoConfig, getConfig, PackageJSONConfig } from '@expo/config';\nimport { ModPlatform } from '@expo/config-plugins';\nimport JsonFile, { JSONObject } from '@expo/json-file';\nimport path from 'path';\n\nimport * as Log from '../log';\nimport { CommandError } from '../utils/errors';\nimport {\n  getOrPromptForBundleIdentifier,\n  getOrPromptForPackage,\n} from '../utils/getOrPromptApplicationId';\n\n/**\n * If an Expo config file does not exist, write a new one using the in-memory config.\n *\n * @param projectRoot\n */\nexport async function ensureConfigExistsAsync(projectRoot: string) {\n  try {\n    const config = getConfig(projectRoot, { skipSDKVersionRequirement: false });\n    // If no config exists in the file system then we should generate one so the process doesn't fail.\n    if (!config.dynamicConfigPath && !config.staticConfigPath) {\n      // Remove the internal object before writing.\n      delete config.exp._internal;\n\n      // Write the generated config.\n      await JsonFile.writeAsync(\n        path.join(projectRoot, 'app.json'),\n        { expo: config.exp as unknown as JSONObject },\n        { json5: false }\n      );\n    }\n  } catch (error: any) {\n    // TODO(Bacon): Currently this is already handled in the command\n    Log.log();\n    throw new CommandError(`${error.message}\\n`);\n  }\n}\n\n/** Ensure config is written, and prompts for application identifiers. */\nexport async function ensureConfigAsync(\n  projectRoot: string,\n  {\n    platforms,\n  }: {\n    platforms: ModPlatform[];\n  }\n): Promise<{ exp: ExpoConfig; pkg: PackageJSONConfig }> {\n  await ensureConfigExistsAsync(projectRoot);\n\n  // Prompt for the Android package first because it's more strict than the bundle identifier\n  // this means you'll have a better chance at matching the bundle identifier with the package name.\n  if (platforms.includes('android')) {\n    await getOrPromptForPackage(projectRoot);\n  }\n\n  if (platforms.includes('ios')) {\n    await getOrPromptForBundleIdentifier(projectRoot);\n  }\n\n  // Read config again because prompting for bundle id or package name may have mutated the results.\n  return getConfig(projectRoot);\n}\n"],"names":["ensureConfigExistsAsync","ensureConfigAsync","projectRoot","config","getConfig","skipSDKVersionRequirement","dynamicConfigPath","staticConfigPath","exp","_internal","JsonFile","writeAsync","path","join","expo","json5","error","Log","log","CommandError","message","platforms","includes","getOrPromptForPackage","getOrPromptForBundleIdentifier"],"mappings":"AAAA;;;;;;;;;;;IAiBsBA,uBAAuB,MAAvBA,uBAAuB;IAuBvBC,iBAAiB,MAAjBA,iBAAiB;;;yBAxCkB,cAAc;;;;;;;8DAElC,iBAAiB;;;;;;;8DACrC,MAAM;;;;;;2DAEF,QAAQ;wBACA,iBAAiB;0CAIvC,mCAAmC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOnC,eAAeD,uBAAuB,CAACE,WAAmB,EAAE;IACjE,IAAI;QACF,MAAMC,MAAM,GAAGC,IAAAA,OAAS,EAAA,UAAA,EAACF,WAAW,EAAE;YAAEG,yBAAyB,EAAE,KAAK;SAAE,CAAC,AAAC;QAC5E,kGAAkG;QAClG,IAAI,CAACF,MAAM,CAACG,iBAAiB,IAAI,CAACH,MAAM,CAACI,gBAAgB,EAAE;YACzD,6CAA6C;YAC7C,OAAOJ,MAAM,CAACK,GAAG,CAACC,SAAS,CAAC;YAE5B,8BAA8B;YAC9B,MAAMC,SAAQ,EAAA,QAAA,CAACC,UAAU,CACvBC,KAAI,EAAA,QAAA,CAACC,IAAI,CAACX,WAAW,EAAE,UAAU,CAAC,EAClC;gBAAEY,IAAI,EAAEX,MAAM,CAACK,GAAG;aAA2B,EAC7C;gBAAEO,KAAK,EAAE,KAAK;aAAE,CACjB,CAAC;QACJ,CAAC;IACH,EAAE,OAAOC,KAAK,EAAO;QACnB,gEAAgE;QAChEC,IAAG,CAACC,GAAG,EAAE,CAAC;QACV,MAAM,IAAIC,OAAY,aAAA,CAAC,CAAC,EAAEH,KAAK,CAACI,OAAO,CAAC,EAAE,CAAC,CAAC,CAAC;IAC/C,CAAC;AACH,CAAC;AAGM,eAAenB,iBAAiB,CACrCC,WAAmB,EACnB,EACEmB,SAAS,CAAA,EAGV,EACqD;IACtD,MAAMrB,uBAAuB,CAACE,WAAW,CAAC,CAAC;IAE3C,2FAA2F;IAC3F,kGAAkG;IAClG,IAAImB,SAAS,CAACC,QAAQ,CAAC,SAAS,CAAC,EAAE;QACjC,MAAMC,IAAAA,yBAAqB,sBAAA,EAACrB,WAAW,CAAC,CAAC;IAC3C,CAAC;IAED,IAAImB,SAAS,CAACC,QAAQ,CAAC,KAAK,CAAC,EAAE;QAC7B,MAAME,IAAAA,yBAA8B,+BAAA,EAACtB,WAAW,CAAC,CAAC;IACpD,CAAC;IAED,kGAAkG;IAClG,OAAOE,IAAAA,OAAS,EAAA,UAAA,EAACF,WAAW,CAAC,CAAC;AAChC,CAAC"}