{"version":3,"sources":["../../../src/prebuild/clearNativeFolder.ts"],"sourcesContent":["import { AndroidConfig, IOSConfig, ModPlatform } from '@expo/config-plugins';\nimport chalk from 'chalk';\nimport fs from 'fs';\nimport path from 'path';\n\nimport * as Log from '../log';\nimport { directoryExistsAsync } from '../utils/dir';\nimport { isInteractive } from '../utils/interactive';\nimport { logNewSection } from '../utils/ora';\nimport { confirmAsync } from '../utils/prompts';\n\ntype ArbitraryPlatform = ModPlatform | string;\n\n/** Delete the input native folders and print a loading step. */\nexport async function clearNativeFolder(projectRoot: string, folders: string[]) {\n  const step = logNewSection(`Clearing ${folders.join(', ')}`);\n  try {\n    await Promise.all(\n      folders.map((folderName) =>\n        fs.promises.rm(path.join(projectRoot, folderName), {\n          recursive: true,\n          force: true,\n        })\n      )\n    );\n    step.succeed(`Cleared ${folders.join(', ')} code`);\n  } catch (error: any) {\n    step.fail(`Failed to delete ${folders.join(', ')} code: ${error.message}`);\n    throw error;\n  }\n}\n\n/**\n * Returns `true` if a certain subset of required Android project files are intact.\n *\n * This isn't perfect but it serves the purpose of indicating that the user should\n * be warned to nuke the project files, most commonly when git is cleared and the root folder\n * remains in memory.\n */\nexport async function hasRequiredAndroidFilesAsync(projectRoot: string): Promise<boolean> {\n  try {\n    await Promise.all([\n      AndroidConfig.Paths.getAppBuildGradleAsync(projectRoot),\n      AndroidConfig.Paths.getProjectBuildGradleAsync(projectRoot),\n      AndroidConfig.Paths.getAndroidManifestAsync(projectRoot),\n      AndroidConfig.Paths.getMainApplicationAsync(projectRoot),\n    ]);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/** Returns `true` if a certain subset of required iOS project files are intact. */\nexport async function hasRequiredIOSFilesAsync(projectRoot: string) {\n  try {\n    // If any of the following required files are missing, then the project is malformed.\n    await Promise.all([\n      IOSConfig.Paths.getAllXcodeProjectPaths(projectRoot),\n      IOSConfig.Paths.getAllPBXProjectPaths(projectRoot),\n    ]);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Filter out platforms that do not have an existing platform folder.\n * If the user wants to validate that neither of ['ios', 'android'] are malformed then we should\n * first check that both `ios` and `android` folders exist.\n *\n * This optimization prevents us from prompting to clear a \"malformed\" project that doesn't exist yet.\n */\nasync function filterPlatformsThatDoNotExistAsync(\n  projectRoot: string,\n  platforms: ArbitraryPlatform[]\n): Promise<ArbitraryPlatform[]> {\n  const valid = await Promise.all(\n    platforms.map(async (platform) => {\n      if (await directoryExistsAsync(path.join(projectRoot, platform))) {\n        return platform;\n      }\n      return null;\n    })\n  );\n  return valid.filter(Boolean) as ArbitraryPlatform[];\n}\n\n/** Get a list of native platforms that have existing directories which contain malformed projects. */\nexport async function getMalformedNativeProjectsAsync(\n  projectRoot: string,\n  platforms: ArbitraryPlatform[]\n): Promise<ArbitraryPlatform[]> {\n  const VERIFIERS: Record<ArbitraryPlatform, (root: string) => Promise<boolean>> = {\n    android: hasRequiredAndroidFilesAsync,\n    ios: hasRequiredIOSFilesAsync,\n  };\n\n  const checkablePlatforms = platforms.filter((platform) => platform in VERIFIERS);\n  const checkPlatforms = await filterPlatformsThatDoNotExistAsync(projectRoot, checkablePlatforms);\n  return (\n    await Promise.all(\n      checkPlatforms.map(async (platform) => {\n        if (!VERIFIERS[platform]) {\n          return false;\n        }\n        if (await VERIFIERS[platform](projectRoot)) {\n          return false;\n        }\n        return platform;\n      })\n    )\n  ).filter(Boolean) as ArbitraryPlatform[];\n}\n\nexport async function promptToClearMalformedNativeProjectsAsync(\n  projectRoot: string,\n  checkPlatforms: ArbitraryPlatform[]\n) {\n  const platforms = await getMalformedNativeProjectsAsync(projectRoot, checkPlatforms);\n\n  if (!platforms.length) {\n    return;\n  }\n\n  const displayPlatforms = platforms.map((platform) => chalk.cyan(platform));\n  // Prompt which platforms to reset.\n  const message =\n    platforms.length > 1\n      ? `The ${displayPlatforms[0]} and ${displayPlatforms[1]} projects are malformed`\n      : `The ${displayPlatforms[0]} project is malformed`;\n\n  if (\n    // If the process is non-interactive, default to clearing the malformed native project.\n    // This would only happen on re-running prebuild.\n    !isInteractive() ||\n    // Prompt to clear the native folders.\n    (await confirmAsync({\n      message: `${message}, would you like to clear the project files and reinitialize them?`,\n      initial: true,\n    }))\n  ) {\n    if (!isInteractive()) {\n      Log.warn(`${message}, project files will be cleared and reinitialized.`);\n    }\n    await clearNativeFolder(projectRoot, platforms);\n  } else {\n    // Warn the user that the process may fail.\n    Log.warn('Continuing with malformed native projects');\n  }\n}\n"],"names":["clearNativeFolder","hasRequiredAndroidFilesAsync","hasRequiredIOSFilesAsync","getMalformedNativeProjectsAsync","promptToClearMalformedNativeProjectsAsync","projectRoot","folders","step","logNewSection","join","Promise","all","map","folderName","fs","promises","rm","path","recursive","force","succeed","error","fail","message","AndroidConfig","Paths","getAppBuildGradleAsync","getProjectBuildGradleAsync","getAndroidManifestAsync","getMainApplicationAsync","IOSConfig","getAllXcodeProjectPaths","getAllPBXProjectPaths","filterPlatformsThatDoNotExistAsync","platforms","valid","platform","directoryExistsAsync","filter","Boolean","VERIFIERS","android","ios","checkablePlatforms","checkPlatforms","length","displayPlatforms","chalk","cyan","isInteractive","confirmAsync","initial","Log","warn"],"mappings":"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"}