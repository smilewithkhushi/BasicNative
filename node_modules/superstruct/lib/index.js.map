{"version":3,"file":"index.js","sources":["../src/error.js","../node_modules/kind-of/index.js","../src/constants.js","../src/utils.js","../src/kinds.js","../src/types.js","../src/superstruct.js","../src/index.js"],"sourcesContent":["/**\n * Define a struct error.\n *\n * @type {StructError}\n */\n\nclass StructError extends TypeError {\n  static format(attrs) {\n    const { type, path, value } = attrs\n    const message = `Expected a value of type \\`${type}\\`${\n      path.length ? ` for \\`${path.join('.')}\\`` : ''\n    } but received \\`${JSON.stringify(value)}\\`.`\n    return message\n  }\n\n  constructor(attrs) {\n    const message = StructError.format(attrs)\n    super(message)\n\n    const { data, path, value, reason, type, errors = [] } = attrs\n    this.data = data\n    this.path = path\n    this.value = value\n    this.reason = reason\n    this.type = type\n    this.errors = errors\n\n    if (!errors.length) {\n      errors.push(this)\n    }\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor)\n    } else {\n      this.stack = new Error().stack\n    }\n  }\n}\n\n/**\n * Export.\n *\n * @type {StructError}\n */\n\nexport default StructError\n","var toString = Object.prototype.toString;\n\nmodule.exports = function kindOf(val) {\n  if (val === void 0) return 'undefined';\n  if (val === null) return 'null';\n\n  var type = typeof val;\n  if (type === 'boolean') return 'boolean';\n  if (type === 'string') return 'string';\n  if (type === 'number') return 'number';\n  if (type === 'symbol') return 'symbol';\n  if (type === 'function') {\n    return isGeneratorFn(val) ? 'generatorfunction' : 'function';\n  }\n\n  if (isArray(val)) return 'array';\n  if (isBuffer(val)) return 'buffer';\n  if (isArguments(val)) return 'arguments';\n  if (isDate(val)) return 'date';\n  if (isError(val)) return 'error';\n  if (isRegexp(val)) return 'regexp';\n\n  switch (ctorName(val)) {\n    case 'Symbol': return 'symbol';\n    case 'Promise': return 'promise';\n\n    // Set, Map, WeakSet, WeakMap\n    case 'WeakMap': return 'weakmap';\n    case 'WeakSet': return 'weakset';\n    case 'Map': return 'map';\n    case 'Set': return 'set';\n\n    // 8-bit typed arrays\n    case 'Int8Array': return 'int8array';\n    case 'Uint8Array': return 'uint8array';\n    case 'Uint8ClampedArray': return 'uint8clampedarray';\n\n    // 16-bit typed arrays\n    case 'Int16Array': return 'int16array';\n    case 'Uint16Array': return 'uint16array';\n\n    // 32-bit typed arrays\n    case 'Int32Array': return 'int32array';\n    case 'Uint32Array': return 'uint32array';\n    case 'Float32Array': return 'float32array';\n    case 'Float64Array': return 'float64array';\n  }\n\n  if (isGeneratorObj(val)) {\n    return 'generator';\n  }\n\n  // Non-plain objects\n  type = toString.call(val);\n  switch (type) {\n    case '[object Object]': return 'object';\n    // iterators\n    case '[object Map Iterator]': return 'mapiterator';\n    case '[object Set Iterator]': return 'setiterator';\n    case '[object String Iterator]': return 'stringiterator';\n    case '[object Array Iterator]': return 'arrayiterator';\n  }\n\n  // other\n  return type.slice(8, -1).toLowerCase().replace(/\\s/g, '');\n};\n\nfunction ctorName(val) {\n  return val.constructor ? val.constructor.name : null;\n}\n\nfunction isArray(val) {\n  if (Array.isArray) return Array.isArray(val);\n  return val instanceof Array;\n}\n\nfunction isError(val) {\n  return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');\n}\n\nfunction isDate(val) {\n  if (val instanceof Date) return true;\n  return typeof val.toDateString === 'function'\n    && typeof val.getDate === 'function'\n    && typeof val.setDate === 'function';\n}\n\nfunction isRegexp(val) {\n  if (val instanceof RegExp) return true;\n  return typeof val.flags === 'string'\n    && typeof val.ignoreCase === 'boolean'\n    && typeof val.multiline === 'boolean'\n    && typeof val.global === 'boolean';\n}\n\nfunction isGeneratorFn(name, val) {\n  return ctorName(name) === 'GeneratorFunction';\n}\n\nfunction isGeneratorObj(val) {\n  return typeof val.throw === 'function'\n    && typeof val.return === 'function'\n    && typeof val.next === 'function';\n}\n\nfunction isArguments(val) {\n  try {\n    if (typeof val.length === 'number' && typeof val.callee === 'function') {\n      return true;\n    }\n  } catch (err) {\n    if (err.message.indexOf('callee') !== -1) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * If you need to support Safari 5-7 (8-10 yr-old browser),\n * take a look at https://github.com/feross/is-buffer\n */\n\nfunction isBuffer(val) {\n  if (val.constructor && typeof val.constructor.isBuffer === 'function') {\n    return val.constructor.isBuffer(val);\n  }\n  return false;\n}\n","/**\n * A private string to identify structs by.\n *\n * @type {String}\n */\n\nconst IS_STRUCT = '@@__STRUCT__@@'\n\n/**\n * A private string to refer to a struct's kind.\n *\n * @type {String}\n */\n\nconst KIND = '@@__KIND__@@'\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport { IS_STRUCT, KIND }\n","import { IS_STRUCT } from './constants'\n\n/**\n * Check if a `value` is a struct.\n *\n * @param {Any} value\n * @return {Boolean}\n */\n\nexport function isStruct(value) {\n  return !!(value && value[IS_STRUCT])\n}\n\n/**\n * Resolve `defaults`, for an optional `value`.\n *\n * @param {Function|Any} defaults\n * @param {Any} value\n * @return {Any}\n */\n\nexport function resolveDefaults(defaults, value) {\n  return typeof defaults === 'function' ? defaults(value) : defaults\n}\n","import kindOf from 'kind-of'\n\nimport { KIND } from './constants'\nimport { isStruct, resolveDefaults } from './utils'\n\n/**\n * Kind.\n *\n * @type {Kind}\n */\n\nclass Kind {\n  constructor(name, type, validate) {\n    this.name = name\n    this.type = type\n    this.validate = validate\n  }\n}\n\n/**\n * Any.\n *\n * @param {Array|Function|Object|String} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction any(schema, defaults, options) {\n  if (isStruct(schema)) {\n    return schema[KIND]\n  }\n\n  if (schema instanceof Kind) {\n    return schema\n  }\n\n  switch (kindOf(schema)) {\n    case 'array': {\n      return schema.length > 1\n        ? tuple(schema, defaults, options)\n        : list(schema, defaults, options)\n    }\n\n    case 'function': {\n      return func(schema, defaults, options)\n    }\n\n    case 'object': {\n      return object(schema, defaults, options)\n    }\n\n    case 'string': {\n      let required = true\n      let type\n\n      if (schema.endsWith('?')) {\n        required = false\n        schema = schema.slice(0, -1)\n      }\n\n      if (schema.includes('|')) {\n        const scalars = schema.split(/\\s*\\|\\s*/g)\n        type = union(scalars, defaults, options)\n      } else if (schema.includes('&')) {\n        const scalars = schema.split(/\\s*&\\s*/g)\n        type = intersection(scalars, defaults, options)\n      } else {\n        type = scalar(schema, defaults, options)\n      }\n\n      if (!required) {\n        type = optional(type, undefined, options)\n      }\n\n      return type\n    }\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    throw new Error(\n      `A schema definition must be an object, array, string or function, but you passed: ${schema}`\n    )\n  } else {\n    throw new Error(`Invalid schema: ${schema}`)\n  }\n}\n\n/**\n * Dict.\n *\n * @param {Array} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction dict(schema, defaults, options) {\n  if (kindOf(schema) !== 'array' || schema.length !== 2) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Dict structs must be defined as an array with two elements, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const obj = scalar('object', undefined, options)\n  const keys = any(schema[0], undefined, options)\n  const values = any(schema[1], undefined, options)\n  const name = 'dict'\n  const type = `dict<${keys.type},${values.type}>`\n  const validate = value => {\n    const resolved = resolveDefaults(defaults)\n    value = resolved ? { ...resolved, ...value } : value\n    const [error] = obj.validate(value)\n\n    if (error) {\n      error.type = type\n      return [error]\n    }\n\n    const ret = {}\n    const errors = []\n\n    for (let k in value) {\n      const v = value[k]\n      const [e, r] = keys.validate(k)\n\n      if (e) {\n        const allE = e.errors || [e]\n        allE.forEach(singleE => {\n          singleE.path = [k].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        continue\n      }\n\n      k = r\n      const [e2, r2] = values.validate(v)\n\n      if (e2) {\n        const allE2 = e2.errors || [e2]\n        allE2.forEach(singleE => {\n          singleE.path = [k].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        continue\n      }\n\n      ret[k] = r2\n    }\n\n    return errors.length ? [{ ...errors[0], errors }] : [undefined, ret]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Enum.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction en(schema, defaults, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Enum structs must be defined as an array, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const name = 'enum'\n  const type = schema\n    .map(s => {\n      try {\n        return JSON.stringify(s)\n      } catch (e) {\n        return String(s)\n      }\n    })\n    .join(' | ')\n\n  const validate = (value = resolveDefaults(defaults)) => {\n    return schema.includes(value)\n      ? [undefined, value]\n      : [{ data: value, path: [], value, type }]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Enums.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction enums(schema, defaults, options) {\n  const e = en(schema, undefined, options)\n  const l = list([e], defaults, options)\n  return l\n}\n\n/**\n * Function.\n *\n * @param {Function} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction func(schema, defaults, options) {\n  if (kindOf(schema) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Function structs must be defined as a function, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const name = 'function'\n  const type = '<function>'\n  const validate = (value = resolveDefaults(defaults), data) => {\n    const result = schema(value, data)\n    let failure = { path: [], reason: null }\n    let isValid\n\n    switch (kindOf(result)) {\n      case 'boolean': {\n        isValid = result\n        break\n      }\n      case 'string': {\n        isValid = false\n        failure.reason = result\n        break\n      }\n      case 'object': {\n        isValid = false\n        failure = { ...failure, ...result }\n        break\n      }\n      default: {\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error(\n            `Validator functions must return a boolean, an error reason string or an error reason object, but you passed: ${schema}`\n          )\n        } else {\n          throw new Error(`Invalid result: ${result}`)\n        }\n      }\n    }\n\n    return isValid\n      ? [undefined, value]\n      : [{ type, value, data: value, ...failure }]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Instance.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction instance(schema, defaults, options) {\n  const name = 'instance'\n  const type = `instance<${schema.name}>`\n  const validate = (value = resolveDefaults(defaults)) => {\n    return value instanceof schema\n      ? [undefined, value]\n      : [{ data: value, path: [], value, type }]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Interface.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction inter(schema, defaults, options) {\n  if (kindOf(schema) !== 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Interface structs must be defined as an object, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const obj = scalar('object', undefined, options)\n  const ks = []\n  const properties = {}\n\n  for (const key in schema) {\n    ks.push(key)\n    const s = schema[key]\n    const kind = any(s, undefined, options)\n    properties[key] = kind\n  }\n\n  const name = 'interface'\n  const type = `{${ks.join()}}`\n  const validate = (value = resolveDefaults(defaults)) => {\n    const [error] = obj.validate(value)\n\n    if (error) {\n      error.type = type\n      return [error]\n    }\n\n    const errors = []\n    const ret = value\n\n    for (const key in properties) {\n      let v = value[key]\n      const kind = properties[key]\n\n      if (v === undefined) {\n        const d = defaults && defaults[key]\n        v = resolveDefaults(d, value)\n      }\n\n      const [e, r] = kind.validate(v, value)\n\n      if (e) {\n        const allE = e.errors || [e]\n        allE.forEach(singleE => {\n          singleE.path = [key].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        continue\n      }\n\n      if (key in value || r !== undefined) {\n        ret[key] = r\n      }\n    }\n\n    return errors.length ? [{ ...errors[0], errors }] : [undefined, ret]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Lazy.\n *\n * @param {Function} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction lazy(schema, defaults, options) {\n  if (kindOf(schema) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Lazy structs must be defined as an function that returns a schema, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  let kind\n  let struct\n  const name = 'lazy'\n  const type = `lazy...`\n  const compile = value => {\n    struct = schema()\n    kind.name = struct.kind\n    kind.type = struct.type\n    kind.validate = struct.validate\n    return kind.validate(value)\n  }\n\n  kind = new Kind(name, type, compile)\n  return kind\n}\n\n/**\n * Dynamic.\n *\n * @param {Function} createSchema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction dynamic(createSchema, defaults, options) {\n  if (kindOf(createSchema) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Dynamic structs must be defined as a function, but you passed: ${createSchema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${createSchema}`)\n    }\n  }\n\n  const name = 'dynamic'\n  const type = 'dynamic...'\n  const validate = (value = resolveDefaults(defaults), data) => {\n    const schema = createSchema(value, data)\n\n    if (kindOf(schema) !== 'function') {\n      if (process.env.NODE_ENV !== 'production') {\n        throw new Error(\n          `Dynamic structs must return a schema, but you passed: ${schema}`\n        )\n      } else {\n        throw new Error(`Invalid schema: ${schema}`)\n      }\n    }\n\n    const [error, result] = schema.validate(value)\n\n    if (error) {\n      return [error]\n    }\n\n    return [undefined, result]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * List.\n *\n * @param {Array} schema\n * @param {Array} defaults\n * @param {Object} options\n */\n\nfunction list(schema, defaults, options) {\n  if (kindOf(schema) !== 'array' || schema.length !== 1) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `List structs must be defined as an array with a single element, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const array = scalar('array', undefined, options)\n  const element = any(schema[0], undefined, options)\n  const name = 'list'\n  const type = `[${element.type}]`\n  const validate = (value = resolveDefaults(defaults)) => {\n    const [error, result] = array.validate(value)\n\n    if (error) {\n      error.type = type\n      return [error]\n    }\n\n    value = result\n    const errors = []\n    const ret = []\n\n    for (let i = 0; i < value.length; i++) {\n      const v = value[i]\n      const [e, r] = element.validate(v)\n\n      if (e) {\n        const allE = e.errors || [e]\n        allE.forEach(singleE => {\n          singleE.path = [i].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        continue\n      }\n\n      ret[i] = r\n    }\n\n    return errors.length ? [{ ...errors[0], errors }] : [undefined, ret]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Literal.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction literal(schema, defaults, options) {\n  const name = 'literal'\n  const type = `literal: ${JSON.stringify(schema)}`\n  const validate = (value = resolveDefaults(defaults)) => {\n    return value === schema\n      ? [undefined, value]\n      : [{ data: value, path: [], value, type }]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Object.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction object(schema, defaults, options) {\n  if (kindOf(schema) !== 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Object structs must be defined as an object, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const obj = scalar('object', undefined, options)\n  const ks = []\n  const properties = {}\n\n  for (const key in schema) {\n    ks.push(key)\n    const s = schema[key]\n    const kind = any(s, undefined, options)\n    properties[key] = kind\n  }\n\n  const name = 'object'\n  const type = `{${ks.join()}}`\n  const validate = (value = resolveDefaults(defaults)) => {\n    const [error] = obj.validate(value)\n\n    if (error) {\n      error.type = type\n      return [error]\n    }\n\n    const errors = []\n    const ret = {}\n    const valueKeys = Object.keys(value)\n    const propertiesKeys = Object.keys(properties)\n    const keys = new Set(valueKeys.concat(propertiesKeys))\n\n    keys.forEach(key => {\n      let v = value[key]\n      const kind = properties[key]\n\n      if (v === undefined) {\n        const d = defaults && defaults[key]\n        v = resolveDefaults(d, value)\n      }\n\n      if (!kind) {\n        const e = { data: value, path: [key], value: v }\n        errors.push(e)\n        return\n      }\n\n      const [e, r] = kind.validate(v, value)\n\n      if (e) {\n        const allE = e.errors || [e]\n        allE.forEach(singleE => {\n          singleE.path = [key].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        return\n      }\n\n      if (key in value || r !== undefined) {\n        ret[key] = r\n      }\n    })\n\n    return errors.length ? [{ ...errors[0], errors }] : [undefined, ret]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Optional.\n *\n * @param {Any} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction optional(schema, defaults, options) {\n  return union([schema, 'undefined'], defaults, options)\n}\n\n/**\n * Partial.\n *\n * @param {Object} schema\n * @param {Object} defaults\n * @param {Object} options\n */\n\nfunction partial(schema, defaults, options) {\n  if (kindOf(schema) !== 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Partial structs must be defined as an object, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const obj = scalar('object', undefined, options)\n  const ks = []\n  const properties = {}\n\n  for (const key in schema) {\n    ks.push(key)\n    const s = schema[key]\n    const kind = any(s, undefined, options)\n    properties[key] = kind\n  }\n\n  const name = 'partial'\n  const type = `{${ks.join()},...}`\n  const validate = (value = resolveDefaults(defaults)) => {\n    const [error] = obj.validate(value)\n\n    if (error) {\n      error.type = type\n      return [error]\n    }\n\n    const errors = []\n    const ret = {}\n\n    for (const key in properties) {\n      let v = value[key]\n      const kind = properties[key]\n\n      if (v === undefined) {\n        const d = defaults && defaults[key]\n        v = resolveDefaults(d, value)\n      }\n\n      const [e, r] = kind.validate(v, value)\n\n      if (e) {\n        const allE = e.errors || [e]\n        allE.forEach(singleE => {\n          singleE.path = [key].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        continue\n      }\n\n      if (key in value || r !== undefined) {\n        ret[key] = r\n      }\n    }\n\n    return errors.length ? [{ ...errors[0], errors }] : [undefined, ret]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Scalar.\n *\n * @param {String} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction scalar(schema, defaults, options) {\n  if (kindOf(schema) !== 'string') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Scalar structs must be defined as a string, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const { types } = options\n  const fn = types[schema]\n\n  if (kindOf(fn) !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `No struct validator function found for type \"${schema}\".`\n      )\n    } else {\n      throw new Error(`Invalid type: ${schema}`)\n    }\n  }\n\n  const kind = func(fn, defaults, options)\n  const name = 'scalar'\n  const type = schema\n  const validate = value => {\n    const [error, result] = kind.validate(value)\n\n    if (error) {\n      error.type = type\n      return [error]\n    }\n\n    return [undefined, result]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Tuple.\n *\n * @param {Array} schema\n * @param {Array} defaults\n * @param {Object} options\n */\n\nfunction tuple(schema, defaults, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Tuple structs must be defined as an array, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const kinds = schema.map(s => any(s, undefined, options))\n  const array = scalar('array', undefined, options)\n  const name = 'tuple'\n  const type = `[${kinds.map(k => k.type).join()}]`\n  const validate = (value = resolveDefaults(defaults)) => {\n    const [error] = array.validate(value)\n\n    if (error) {\n      error.type = type\n      return [error]\n    }\n\n    const ret = []\n    const errors = []\n    const length = Math.max(value.length, kinds.length)\n\n    for (let i = 0; i < length; i++) {\n      const kind = kinds[i]\n      const v = value[i]\n\n      if (!kind) {\n        const e = { data: value, path: [i], value: v }\n        errors.push(e)\n        continue\n      }\n\n      const [e, r] = kind.validate(v)\n\n      if (e) {\n        const allE = e.errors || [e]\n        allE.forEach(singleE => {\n          singleE.path = [i].concat(singleE.path)\n          singleE.data = value\n          errors.push(singleE)\n        })\n        continue\n      }\n\n      ret[i] = r\n    }\n\n    return errors.length ? [{ ...errors[0], errors }] : [undefined, ret]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Union.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction union(schema, defaults, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Union structs must be defined as an array, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const kinds = schema.map(s => any(s, undefined, options))\n  const name = 'union'\n  const type = kinds.map(k => k.type).join(' | ')\n  const validate = (value = resolveDefaults(defaults)) => {\n    const errors = []\n\n    for (const k of kinds) {\n      const [e, r] = k.validate(value)\n\n      if (!e) {\n        return [undefined, r]\n      }\n\n      errors.push(e)\n    }\n    errors[0].type = type\n    return errors\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Intersection.\n *\n * @param {Array} schema\n * @param {Any} defaults\n * @param {Object} options\n */\n\nfunction intersection(schema, defaults, options) {\n  if (kindOf(schema) !== 'array') {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        `Intersection structs must be defined as an array, but you passed: ${schema}`\n      )\n    } else {\n      throw new Error(`Invalid schema: ${schema}`)\n    }\n  }\n\n  const types = schema.map(s => any(s, undefined, options))\n  const name = 'intersection'\n  const type = types.map(t => t.type).join(' & ')\n  const validate = (value = resolveDefaults(defaults)) => {\n    let v = value\n\n    for (const t of types) {\n      const [e, r] = t.validate(v)\n\n      if (e) {\n        e.type = type\n        return [e]\n      }\n\n      v = r\n    }\n\n    return [undefined, v]\n  }\n\n  return new Kind(name, type, validate)\n}\n\n/**\n * Kinds.\n *\n * @type {Object}\n */\n\nconst Kinds = {\n  any,\n  dict,\n  enum: en,\n  enums,\n  function: func,\n  instance,\n  interface: inter,\n  lazy,\n  list,\n  literal,\n  object,\n  optional,\n  partial,\n  scalar,\n  tuple,\n  union,\n  intersection,\n  dynamic,\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Kinds\n","import kindOf from 'kind-of'\n\n/**\n * The types that `kind-of` supports.\n *\n * @type {Array}\n */\n\nconst TYPES = [\n  'arguments',\n  'array',\n  'boolean',\n  'buffer',\n  'error',\n  'float32array',\n  'float64array',\n  'function',\n  'generatorfunction',\n  'int16array',\n  'int32array',\n  'int8array',\n  'map',\n  'null',\n  'number',\n  'object',\n  'promise',\n  'regexp',\n  'set',\n  'string',\n  'symbol',\n  'uint16array',\n  'uint32array',\n  'uint8array',\n  'uint8clampedarray',\n  'undefined',\n  'weakmap',\n  'weakset',\n]\n\n/**\n * The default types that Superstruct ships with.\n *\n * @type {Object}\n */\n\nconst Types = {\n  any: value => value !== undefined,\n}\n\nTYPES.forEach(type => {\n  Types[type] = value => kindOf(value) === type\n})\n\n/**\n * Handle the 'date' case specially, to throw out invalid `Date` objects.\n *\n * @param {Mixed} value\n * @return {Boolean}\n */\n\nTypes.date = value => kindOf(value) === 'date' && !isNaN(value)\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Types\n","import Kinds from './kinds'\nimport StructError from './error'\nimport Types from './types'\nimport { isStruct } from './utils'\nimport { IS_STRUCT, KIND } from './constants'\n\n/**\n * Create a struct factory with a `config`.\n *\n * @param {Object} config\n * @return {Function}\n */\n\nfunction superstruct(config = {}) {\n  const types = {\n    ...Types,\n    ...(config.types || {}),\n  }\n\n  /**\n   * Create a `kind` struct with `schema`, `defaults` and `options`.\n   *\n   * @param {Any} schema\n   * @param {Any} defaults\n   * @param {Object} options\n   * @return {Function}\n   */\n\n  function struct(schema, defaults, options = {}) {\n    if (isStruct(schema)) {\n      schema = schema.schema\n    }\n\n    const kind = Kinds.any(schema, defaults, { ...options, types })\n\n    function Struct(data) {\n      if (this instanceof Struct) {\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error(\n            'The `Struct` creation function should not be used with the `new` keyword.'\n          )\n        } else {\n          throw new Error('Invalid `new` keyword!')\n        }\n      }\n\n      return Struct.assert(data)\n    }\n\n    Object.defineProperty(Struct, IS_STRUCT, { value: true })\n    Object.defineProperty(Struct, KIND, { value: kind })\n\n    Struct.kind = kind.name\n    Struct.type = kind.type\n    Struct.schema = schema\n    Struct.defaults = defaults\n    Struct.options = options\n\n    Struct.assert = value => {\n      const [error, result] = kind.validate(value)\n\n      if (error) {\n        throw new StructError(error)\n      }\n\n      return result\n    }\n\n    Struct.test = value => {\n      const [error] = kind.validate(value)\n      return !error\n    }\n\n    Struct.validate = value => {\n      const [error, result] = kind.validate(value)\n\n      if (error) {\n        return [new StructError(error)]\n      }\n\n      return [undefined, result]\n    }\n\n    return Struct\n  }\n\n  /**\n   * Mix in a factory for each specific kind of struct.\n   */\n\n  Object.keys(Kinds).forEach(name => {\n    const kind = Kinds[name]\n\n    struct[name] = (schema, defaults, options) => {\n      const type = kind(schema, defaults, { ...options, types })\n      const s = struct(type, defaults, options)\n      return s\n    }\n  })\n\n  /**\n   * Return the struct factory.\n   */\n\n  return struct\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default superstruct\n","import StructError from './error'\nimport superstruct from './superstruct'\nimport { isStruct } from './utils'\n\n/**\n * Create a convenience `struct` factory for the default types.\n *\n * @type {Function}\n */\n\nconst struct = superstruct()\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport { struct, superstruct, isStruct, StructError }\n"],"names":["StructError","TypeError","format","attrs","type","path","value","message","length","join","JSON","stringify","data","reason","errors","push","Error","captureStackTrace","constructor","stack","IS_STRUCT","KIND","isStruct","resolveDefaults","defaults","Kind","name","validate","any","schema","options","kindOf","tuple","list","func","object","required","endsWith","slice","includes","scalars","split","union","intersection","scalar","optional","undefined","process","env","NODE_ENV","dict","obj","keys","values","resolved","error","ret","k","v","e","r","allE","forEach","singleE","concat","e2","r2","allE2","en","map","s","String","enums","l","result","failure","isValid","instance","inter","ks","properties","key","kind","d","lazy","struct","compile","dynamic","createSchema","array","element","i","literal","valueKeys","Object","propertiesKeys","Set","partial","types","fn","kinds","Math","max","t","Kinds","TYPES","Types","date","isNaN","superstruct","config","Struct","assert","defineProperty","test"],"mappings":"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"}