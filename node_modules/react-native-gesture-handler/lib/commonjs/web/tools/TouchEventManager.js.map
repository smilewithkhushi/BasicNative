{"version":3,"sources":["TouchEventManager.ts"],"names":["TouchEventManager","EventManager","event","i","changedTouches","length","adaptedEvent","mapEvent","EventTypes","DOWN","TouchEventType","view","x","y","touchType","markAsInBounds","pointerId","activePointersCounter","eventType","ADDITIONAL_POINTER_DOWN","onPointerAdd","onPointerDown","MOVE","inBounds","pointerIndex","pointersInBounds","indexOf","ENTER","onPointerEnter","onPointerMove","LEAVE","onPointerLeave","markAsOutOfBounds","onPointerOutOfBounds","UP","ADDITIONAL_POINTER_UP","onPointerRemove","onPointerUp","CANCEL","CANCELLED","onPointerCancel","registerListeners","addEventListener","touchStartCallback","touchMoveCallback","touchEndCallback","touchCancelCallback","unregisterListeners","removeEventListener","index","touchEventType","rect","getBoundingClientRect","clientX","clientY","offsetX","left","offsetY","top","identifier","pointerType","PointerType","TOUCH","time","timeStamp","allTouches","touches"],"mappings":"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","sourcesContent":["import { AdaptedEvent, EventTypes, TouchEventType } from '../interfaces';\nimport EventManager from './EventManager';\nimport { isPointerInBounds } from '../utils';\nimport { PointerType } from '../../PointerType';\n\nexport default class TouchEventManager extends EventManager<HTMLElement> {\n  private touchStartCallback = (event: TouchEvent): void => {\n    for (let i = 0; i < event.changedTouches.length; ++i) {\n      const adaptedEvent: AdaptedEvent = this.mapEvent(\n        event,\n        EventTypes.DOWN,\n        i,\n        TouchEventType.DOWN\n      );\n\n      // Here we skip stylus, because in case of anything different than touch we want to handle it by using PointerEvents\n      // If we leave stylus to send touch events, handlers will receive every action twice\n      if (\n        !isPointerInBounds(this.view, {\n          x: adaptedEvent.x,\n          y: adaptedEvent.y,\n        }) ||\n        //@ts-ignore touchType field does exist\n        event.changedTouches[i].touchType === 'stylus'\n      ) {\n        continue;\n      }\n\n      this.markAsInBounds(adaptedEvent.pointerId);\n\n      if (++this.activePointersCounter > 1) {\n        adaptedEvent.eventType = EventTypes.ADDITIONAL_POINTER_DOWN;\n        this.onPointerAdd(adaptedEvent);\n      } else {\n        this.onPointerDown(adaptedEvent);\n      }\n    }\n  };\n\n  private touchMoveCallback = (event: TouchEvent): void => {\n    for (let i = 0; i < event.changedTouches.length; ++i) {\n      const adaptedEvent: AdaptedEvent = this.mapEvent(\n        event,\n        EventTypes.MOVE,\n        i,\n        TouchEventType.MOVE\n      );\n      //@ts-ignore touchType field does exist\n      if (event.changedTouches[i].touchType === 'stylus') {\n        continue;\n      }\n\n      const inBounds: boolean = isPointerInBounds(this.view, {\n        x: adaptedEvent.x,\n        y: adaptedEvent.y,\n      });\n\n      const pointerIndex: number = this.pointersInBounds.indexOf(\n        adaptedEvent.pointerId\n      );\n\n      if (inBounds) {\n        if (pointerIndex < 0) {\n          adaptedEvent.eventType = EventTypes.ENTER;\n          this.onPointerEnter(adaptedEvent);\n          this.markAsInBounds(adaptedEvent.pointerId);\n        } else {\n          this.onPointerMove(adaptedEvent);\n        }\n      } else {\n        if (pointerIndex >= 0) {\n          adaptedEvent.eventType = EventTypes.LEAVE;\n          this.onPointerLeave(adaptedEvent);\n          this.markAsOutOfBounds(adaptedEvent.pointerId);\n        } else {\n          this.onPointerOutOfBounds(adaptedEvent);\n        }\n      }\n    }\n  };\n\n  private touchEndCallback = (event: TouchEvent): void => {\n    for (let i = 0; i < event.changedTouches.length; ++i) {\n      // When we call reset on gesture handlers, it also resets their event managers\n      // In some handlers (like RotationGestureHandler) reset is called before all pointers leave view\n      // This means, that activePointersCounter will be set to 0, while there are still remaining pointers on view\n      // Removing them will end in activePointersCounter going below 0, therefore handlers won't behave properly\n      if (this.activePointersCounter === 0) {\n        break;\n      }\n\n      //@ts-ignore touchType field does exist\n      if (event.changedTouches[i].touchType === 'stylus') {\n        continue;\n      }\n\n      const adaptedEvent: AdaptedEvent = this.mapEvent(\n        event,\n        EventTypes.UP,\n        i,\n        TouchEventType.UP\n      );\n\n      this.markAsOutOfBounds(adaptedEvent.pointerId);\n\n      if (--this.activePointersCounter > 0) {\n        adaptedEvent.eventType = EventTypes.ADDITIONAL_POINTER_UP;\n        this.onPointerRemove(adaptedEvent);\n      } else {\n        this.onPointerUp(adaptedEvent);\n      }\n    }\n  };\n\n  private touchCancelCallback = (event: TouchEvent): void => {\n    for (let i = 0; i < event.changedTouches.length; ++i) {\n      const adaptedEvent: AdaptedEvent = this.mapEvent(\n        event,\n        EventTypes.CANCEL,\n        i,\n        TouchEventType.CANCELLED\n      );\n\n      //@ts-ignore touchType field does exist\n      if (event.changedTouches[i].touchType === 'stylus') {\n        continue;\n      }\n\n      this.onPointerCancel(adaptedEvent);\n      this.markAsOutOfBounds(adaptedEvent.pointerId);\n      this.activePointersCounter = 0;\n    }\n  };\n\n  public registerListeners(): void {\n    this.view.addEventListener('touchstart', this.touchStartCallback);\n    this.view.addEventListener('touchmove', this.touchMoveCallback);\n    this.view.addEventListener('touchend', this.touchEndCallback);\n    this.view.addEventListener('touchcancel', this.touchCancelCallback);\n  }\n\n  public unregisterListeners(): void {\n    this.view.removeEventListener('touchstart', this.touchStartCallback);\n    this.view.removeEventListener('touchmove', this.touchMoveCallback);\n    this.view.removeEventListener('touchend', this.touchEndCallback);\n    this.view.removeEventListener('touchcancel', this.touchCancelCallback);\n  }\n\n  protected mapEvent(\n    event: TouchEvent,\n    eventType: EventTypes,\n    index: number,\n    touchEventType: TouchEventType\n  ): AdaptedEvent {\n    const rect = this.view.getBoundingClientRect();\n    const clientX = event.changedTouches[index].clientX;\n    const clientY = event.changedTouches[index].clientY;\n\n    return {\n      x: clientX,\n      y: clientY,\n      offsetX: clientX - rect.left,\n      offsetY: clientY - rect.top,\n      pointerId: event.changedTouches[index].identifier,\n      eventType: eventType,\n      pointerType: PointerType.TOUCH,\n      time: event.timeStamp,\n      allTouches: event.touches,\n      changedTouches: event.changedTouches,\n      touchEventType: touchEventType,\n    };\n  }\n}\n"]}